//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

package sql

import (
	"fmt"
	"sort"
	"strings"

	"github.com/88250/lute/ast"
	"github.com/siyuan-note/siyuan/kernel/av"
	"github.com/siyuan-note/siyuan/kernel/util"
)

func RenderAttributeViewTable(attrView *av.AttributeView, view *av.View, query string) (ret *av.Table) {
	ret = &av.Table{
		BaseInstance: &av.BaseInstance{
			ID:               view.ID,
			Icon:             view.Icon,
			Name:             view.Name,
			Desc:             view.Desc,
			HideAttrViewName: view.HideAttrViewName,
			Filters:          view.Table.Filters,
			Sorts:            view.Table.Sorts,
		},
		Columns: []*av.TableColumn{},
		Rows:    []*av.TableRow{},
	}

	// 组装列
	for _, col := range view.Table.Columns {
		key, getErr := attrView.GetKey(col.ID)
		if nil != getErr {
			// 找不到字段则在视图中删除
			removeMissingField(attrView, view, col.ID)
			continue
		}

		ret.Columns = append(ret.Columns, &av.TableColumn{
			BaseInstanceField: &av.BaseInstanceField{
				ID:           key.ID,
				Name:         key.Name,
				Type:         key.Type,
				Icon:         key.Icon,
				Hidden:       col.Hidden,
				Desc:         key.Desc,
				Options:      key.Options,
				NumberFormat: key.NumberFormat,
				Template:     key.Template,
				Relation:     key.Relation,
				Rollup:       key.Rollup,
				Date:         key.Date,
			},
			Wrap:  col.Wrap,
			Width: col.Width,
			Pin:   col.Pin,
			Calc:  col.Calc,
		})
	}

	rowsValues := generateAttrViewItems(attrView) // 生成行
	filterNotFoundAttrViewItems(&rowsValues)      // 过滤掉不存在的行

	// 生成行单元格
	for rowID, rowValues := range rowsValues {
		var tableRow av.TableRow
		for _, col := range ret.Columns {
			var tableCell *av.TableCell
			for _, keyValues := range rowValues {
				if keyValues.Key.ID == col.ID {
					tableCell = &av.TableCell{
						BaseValue: &av.BaseValue{
							ID:        keyValues.Values[0].ID,
							Value:     keyValues.Values[0],
							ValueType: col.Type,
						},
					}
					break
				}
			}
			if nil == tableCell {
				tableCell = &av.TableCell{
					BaseValue: &av.BaseValue{
						ID:        ast.NewNodeID(),
						ValueType: col.Type,
					},
				}
			}
			tableRow.ID = rowID

			fillAttributeViewBaseValue(tableCell.BaseValue, col.ID, rowID, col.NumberFormat, col.Template)
			tableRow.Cells = append(tableRow.Cells, tableCell)
		}
		ret.Rows = append(ret.Rows, &tableRow)
	}

	// 批量获取块属性以提升性能
	var ialIDs []string
	for _, row := range ret.Rows {
		block := row.GetBlockValue()
		if nil != block && !block.IsDetached {
			ialIDs = append(ialIDs, row.ID)
		}
	}
	ials := BatchGetBlockAttrs(ialIDs)

	// 渲染自动生成的列值，比如关联列、汇总列、创建时间列和更新时间列
	avCache := map[string]*av.AttributeView{}
	avCache[attrView.ID] = attrView
	for _, row := range ret.Rows {
		for _, cell := range row.Cells {
			fillAttributeViewAutoGeneratedValues(attrView, ials, cell.Value, row, rowsValues, &avCache)
		}
	}

	// 最后单独渲染模板列，这样模板列就可以使用汇总、关联、创建时间和更新时间列的值了
	// Database table view template columns support reading relation, rollup, created and updated columns https://github.com/siyuan-note/siyuan/issues/10442

	var renderTemplateErr error
	for _, row := range ret.Rows {
		for _, cell := range row.Cells {
			switch cell.ValueType {
			case av.KeyTypeTemplate: // 渲染模板列
				keyValues := rowsValues[row.ID]
				ial := ials[row.ID]
				if nil == ial {
					ial = map[string]string{}
				}
				content, renderErr := RenderTemplateField(ial, keyValues, cell.Value.Template.Content)
				cell.Value.Template.Content = content
				if nil != renderErr {
					key, _ := attrView.GetKey(cell.Value.KeyID)
					keyName := ""
					if nil != key {
						keyName = key.Name
					}
					renderTemplateErr = fmt.Errorf("database [%s] template field [%s] rendering failed: %s", getAttrViewName(attrView), keyName, renderErr)
				}
			}
		}
	}
	if nil != renderTemplateErr {
		util.PushErrMsg(fmt.Sprintf(util.Langs[util.Lang][44], util.EscapeHTML(renderTemplateErr.Error())), 30000)
	}

	// 根据搜索条件过滤
	query = strings.TrimSpace(query)
	if "" != query {
		// 将连续空格转换为一个空格
		query = strings.Join(strings.Fields(query), " ")
		// 按空格分割关键字
		keywords := strings.Split(query, " ")
		// 使用 AND 逻辑 https://github.com/siyuan-note/siyuan/issues/11535
		var hitRows []*av.TableRow
		for _, row := range ret.Rows {
			hit := false
			for _, cell := range row.Cells {
				allKeywordsHit := true
				for _, keyword := range keywords {
					if !strings.Contains(strings.ToLower(cell.Value.String(true)), strings.ToLower(keyword)) {
						allKeywordsHit = false
						break
					}
				}
				if allKeywordsHit {
					hit = true
					break
				}
			}
			if hit {
				hitRows = append(hitRows, row)
			}
		}
		ret.Rows = hitRows
		if 1 > len(ret.Rows) {
			ret.Rows = []*av.TableRow{}
		}
	}

	// 自定义排序
	sortRowIDs := map[string]int{}
	if 0 < len(view.Table.RowIDs) {
		for i, rowID := range view.Table.RowIDs {
			sortRowIDs[rowID] = i
		}
	}

	sort.Slice(ret.Rows, func(i, j int) bool {
		iv := sortRowIDs[ret.Rows[i].ID]
		jv := sortRowIDs[ret.Rows[j].ID]
		if iv == jv {
			return ret.Rows[i].ID < ret.Rows[j].ID
		}
		return iv < jv
	})
	return
}
